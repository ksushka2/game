import pygame
import sys

cell_size = 68
board_size = 8
window_size_w = 1100
window_size_h = 700
board_offset = window_size_w - (cell_size * board_size) - 50
board_offset_y = 50
white = (227, 214, 200)
black = (0, 0, 0)
gray = (130, 163, 194)
fps = 60


class LoginScreen:
    def __init__(self, screen):
        self.screen = screen
        self.font_header = pygame.font.SysFont('Arial', 30)
        self.font_entry = pygame.font.SysFont('Arial', 24)
        self.font_label = pygame.font.SysFont('Arial', 22)

        self.username = ""
        self.password = ""
        self.active_input = None
        self.show_register_popup = False
        self.is_registration = False
        self.show_success_popup = False
        self.game_started = False
        self.success_popup_start_time = 0

        self.username_rect = pygame.Rect(window_size_w // 2 - 100, 150, 200, 30)
        self.password_rect = pygame.Rect(window_size_w // 2 - 100, 250, 200, 30)
        self.login_btn = pygame.Rect(window_size_w // 2 - 50, 330, 100, 40)

        self.popup_rect = pygame.Rect(window_size_w // 2 - 200, window_size_h // 2 - 100, 400, 200)
        self.yes_btn = pygame.Rect(window_size_w // 2 - 100, window_size_h // 2 + 20, 80, 40)
        self.no_btn = pygame.Rect(window_size_w // 2 + 20, window_size_h // 2 + 20, 80, 40)

    def caesar_cipher(self, text, shift=6):
        result = ""
        for char in text:
            if 'А' <= char <= 'Я' or 'а' <= char <= 'я':
                ascii_offset = ord('а') if char.islower() else ord('А')
                shifted = (ord(char) - ascii_offset + shift) % 32 + ascii_offset
                result += chr(shifted)
            else:
                result += char
        return result

    def caesar_decipher(self, text, shift=6):
        return self.caesar_cipher(text, -shift)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if not self.show_register_popup and not self.show_success_popup:
                if self.username_rect.collidepoint(event.pos):
                    self.active_input = "username"
                elif self.password_rect.collidepoint(event.pos):
                    self.active_input = "password"
                elif self.login_btn.collidepoint(event.pos):
                    if self.is_registration:
                        if self.register_user():
                            self.show_success_popup = True
                            self.success_popup_start_time = pygame.time.get_ticks()
                    else:
                        self.login()
                else:
                    self.active_input = None
            elif self.show_register_popup:
                if self.yes_btn.collidepoint(event.pos):
                    self.is_registration = True
                    self.show_register_popup = False
                elif self.no_btn.collidepoint(event.pos):
                    self.show_register_popup = False
                    self.username = ""
                    self.password = ""

        elif event.type == pygame.KEYDOWN and self.active_input and not self.show_register_popup and not self.show_success_popup:
            if event.key == pygame.K_BACKSPACE:
                if self.active_input == "username":
                    self.username = self.username[:-1]
                else:
                    self.password = self.password[:-1]
            elif event.key == pygame.K_RETURN:
                if self.is_registration:
                    if self.register_user():
                        self.show_success_popup = True
                        self.success_popup_start_time = pygame.time.get_ticks()
                else:
                    self.login()
            else:
                if self.active_input == "username":
                    self.username += event.unicode
                else:
                    self.password += event.unicode

    def login(self):
        try:
            with open('users.txt', 'r', encoding='utf-8') as file:
                for line in file:
                    encrypted_line = line.strip()
                    decrypted_line = self.caesar_decipher(encrypted_line)
                    stored_username, stored_password = decrypted_line.split(':')
                    if stored_username.strip() == self.username and stored_password.strip() == self.password:
                        self.game_started = True
                        return True
            self.show_register_popup = True
            return False
        except FileNotFoundError:
            with open('users.txt', 'w', encoding='utf-8') as file:
                pass
            self.show_register_popup = True
            return False

    def register_user(self):
        if self.username and self.password:
            user_data = f"{self.username}:{self.password}"
            encrypted_data = self.caesar_cipher(user_data)
            with open('users.txt', 'a', encoding='utf-8') as file:
                file.write(encrypted_data + '\n')
            return True
        return False

    def draw(self):
        if self.game_started:
            return

        header_text = "Регистрация" if self.is_registration else "Авторизация"
        header = self.font_header.render(header_text, True, black)
        header_rect = header.get_rect(center=(window_size_w // 2, 80))
        self.screen.blit(header, header_rect)

        username_label = self.font_label.render("Имя пользователя", True, black)
        self.screen.blit(username_label, (window_size_w // 2 - 100, 120))

        pygame.draw.rect(self.screen, gray if self.active_input == "username" else black,
                         self.username_rect, 2)
        username_text = self.font_entry.render(self.username, True, black)
        self.screen.blit(username_text, (self.username_rect.x + 5, self.username_rect.y + 5))

        password_label = self.font_label.render("Пароль", True, black)
        self.screen.blit(password_label, (window_size_w // 2 - 100, 220))

        pygame.draw.rect(self.screen, gray if self.active_input == "password" else black,
                         self.password_rect, 2)
        hidden_password = "*" * len(self.password)
        password_text = self.font_entry.render(hidden_password, True, black)
        self.screen.blit(password_text, (self.password_rect.x + 5, self.password_rect.y + 5))

        pygame.draw.rect(self.screen, gray, self.login_btn)
        button_text = "Сохранить" if self.is_registration else "Войти"
        login_text = self.font_label.render(button_text, True, black)
        login_text_rect = login_text.get_rect(center=self.login_btn.center)
        self.screen.blit(login_text, login_text_rect)

        if self.show_register_popup:
            overlay = pygame.Surface((window_size_w, window_size_h))
            overlay.fill((0, 0, 0))
            overlay.set_alpha(128)
            self.screen.blit(overlay, (0, 0))

            pygame.draw.rect(self.screen, white, self.popup_rect)
            pygame.draw.rect(self.screen, black, self.popup_rect, 2)

            popup_header = self.font_header.render("Зарегистрироваться", True, black)
            popup_header_rect = popup_header.get_rect(center=(window_size_w // 2, window_size_h // 2 - 70))
            self.screen.blit(popup_header, popup_header_rect)

            popup_text = self.font_label.render("Имя пользователя и пароль не найдены", True, black)
            popup_text2 = self.font_label.render("зарегистрироваться?", True, black)
            popup_text_rect = popup_text.get_rect(center=(window_size_w // 2, window_size_h // 2 - 20))
            popup_text_rect2 = popup_text2.get_rect(center=(window_size_w // 2, window_size_h // 2))
            self.screen.blit(popup_text, popup_text_rect)
            self.screen.blit(popup_text2, popup_text_rect2)

            pygame.draw.rect(self.screen, gray, self.yes_btn)
            pygame.draw.rect(self.screen, gray, self.no_btn)

            yes_text = self.font_label.render("Да", True, black)
            no_text = self.font_label.render("Нет", True, black)

            yes_text_rect = yes_text.get_rect(center=self.yes_btn.center)
            no_text_rect = no_text.get_rect(center=self.no_btn.center)

            self.screen.blit(yes_text, yes_text_rect)
            self.screen.blit(no_text, no_text_rect)


class Checker:
    def __init__(self, row, col, player, game):
        self.row = row
        self.col = col
        self.x = col * cell_size + board_offset + cell_size // 2 - game.white_checker_img.get_width() // 2
        self.y = row * cell_size + board_offset_y + cell_size // 2 - game.white_checker_img.get_height() // 2
        self.selected = False
        self.player = player
        self.game = game

        self.animating = False
        self.animation_path = []
        self.current_path_index = 0
        self.animation_progress = 0
        self.start_x = self.x
        self.start_y = self.y
        self.target_x = self.x
        self.target_y = self.y

    def start_animation(self, path):
        self.animating = True
        self.animation_path = path
        self.current_path_index = 0
        self.animation_progress = 0
        self.start_x = self.x
        self.start_y = self.y
        if path:
            next_row, next_col = path[0]
            self.target_x = next_col * cell_size + board_offset + cell_size // 2 - self.game.white_checker_img.get_width() // 2
            self.target_y = next_row * cell_size + board_offset_y + cell_size // 2 - self.game.white_checker_img.get_height() // 2

    def update_animation(self):
        if self.animating:
            self.animation_progress += 0.1
            if self.animation_progress >= 1:
                self.x = self.target_x
                self.y = self.target_y
                self.current_path_index += 1

                if self.current_path_index < len(self.animation_path):
                    self.animation_progress = 0
                    self.start_x = self.x
                    self.start_y = self.y
                    next_row, next_col = self.animation_path[self.current_path_index]
                    self.target_x = next_col * cell_size + board_offset + cell_size // 2 - self.game.white_checker_img.get_width() // 2
                    self.target_y = next_row * cell_size + board_offset_y + cell_size // 2 - self.game.white_checker_img.get_height() // 2
                else:
                    self.animating = False
                    self.game.animating = False
                    if self.animation_path:
                        final_row, final_col = self.animation_path[-1]
                        self.row = final_row
                        self.col = final_col
            else:
                t = self.animation_progress
                t = t * t * (3 - 2 * t)
                self.x = self.start_x + (self.target_x - self.start_x) * t
                self.y = self.start_y + (self.target_y - self.start_y) * t

    def draw(self):
        self.update_animation()
        if self.player == 1:
            self.game.screen.blit(self.game.white_checker_img, (self.x, self.y))
        else:
            self.game.screen.blit(self.game.black_checker_img, (self.x, self.y))
        if self.selected:
            pygame.draw.rect(self.game.screen, (74, 75, 77),
                             (self.col * cell_size + board_offset,
                              self.row * cell_size + board_offset_y,
                              cell_size, cell_size), 2)

    def move(self, row, col):
        self.row = row
        self.col = col
        self.x = col * cell_size + board_offset + cell_size // 2 - self.game.white_checker_img.get_width() // 2
        self.y = row * cell_size + board_offset_y + cell_size // 2 - self.game.white_checker_img.get_height() // 2


class Board:
    def __init__(self, game):
        self.game = game
        self.board = [[None for _ in range(board_size)] for _ in range(board_size)]
        self.init_board()
        self.last_move = None

    def init_board(self):
        initial_position = [
            [0, 0, 0, 0, 0, -1, -1, -1],
            [0, 0, 0, 0, 0, -1, -1, -1],
            [0, 0, 0, 0, 0, -1, -1, -1],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 0, 0, 0, 0, 0]
        ]

        for row in range(board_size):
            for col in range(board_size):
                if initial_position[row][col] != 0:
                    self.board[row][col] = Checker(row, col, initial_position[row][col], self.game)

    def check_winner(self):
        # Проверка победы белых (достигли верхнего правого угла)
        white_win = (self.board[0][5] is not None and self.board[0][5].player == 1 and
                     self.board[0][6] is not None and self.board[0][6].player == 1 and
                     self.board[0][7] is not None and self.board[0][7].player == 1 and
                     self.board[1][5] is not None and self.board[1][5].player == 1 and
                     self.board[1][6] is not None and self.board[1][6].player == 1 and
                     self.board[1][7] is not None and self.board[1][7].player == 1 and
                     self.board[2][5] is not None and self.board[2][5].player == 1 and
                     self.board[2][6] is not None and self.board[2][6].player == 1 and
                     self.board[2][7] is not None and self.board[2][7].player == 1)

        # Проверка победы черных (достигли нижнего левого угла)
        black_win = (self.board[5][0] is not None and self.board[5][0].player == -1 and
                     self.board[5][1] is not None and self.board[5][1].player == -1 and
                     self.board[5][2] is not None and self.board[5][2].player == -1 and
                     self.board[6][0] is not None and self.board[6][0].player == -1 and
                     self.board[6][1] is not None and self.board[6][1].player == -1 and
                     self.board[6][2] is not None and self.board[6][2].player == -1 and
                     self.board[7][0] is not None and self.board[7][0].player == -1 and
                     self.board[7][1] is not None and self.board[7][1].player == -1 and
                     self.board[7][2] is not None and self.board[7][2].player == -1)

        if white_win and black_win:
            return 0  # Ничья
        elif white_win:
            return 1  # Победа белых
        elif black_win:
            return -1  # Победа черных
        else:
            return 0  # Игра не окончена

    def get_path(self, start_row, start_col, end_row, end_col):
        path = [(start_row, start_col)]
        current_row, current_col = start_row, start_col

        if abs(start_row - end_row) + abs(start_col - end_col) == 1:
            path.append((end_row, end_col))
            return path

        while (current_row, current_col) != (end_row, end_col):
            if abs(current_row - end_row) >= 2:
                next_row = current_row + 2 * (1 if end_row > current_row else -1)
                next_col = current_col
                if self.can_jump(current_row, current_col, next_row, next_col):
                    path.append((next_row, next_col))
                    current_row = next_row
                    continue

            if abs(current_col - end_col) >= 2:
                next_row = current_row
                next_col = current_col + 2 * (1 if end_col > current_col else -1)
                if self.can_jump(current_row, current_col, next_row, next_col):
                    path.append((next_row, next_col))
                    current_col = next_col
                    continue

            break

        return path

    def can_jump(self, start_row, start_col, end_row, end_col):
        if self.board[end_row][end_col] is not None:
            return False

        if not (start_row == end_row or start_col == end_col):
            return False

        if start_row == end_row:
            mid_col = (start_col + end_col) // 2
            return (abs(start_col - end_col) == 2 and
                    self.board[start_row][mid_col] is not None)
        else:
            mid_row = (start_row + end_row) // 2
            return (abs(start_row - end_row) == 2 and
                    self.board[mid_row][start_col] is not None)

    def get_possible_jumps(self, row, col, visited=None):
        if visited is None:
            visited = set()

        possible_moves = set()
        directions = [(0, -2), (0, 2), (-2, 0), (2, 0)]

        for d_row, d_col in directions:
            new_row = row + d_row
            new_col = col + d_col

            if (0 <= new_row < board_size and 0 <= new_col < board_size and
                    (new_row, new_col) not in visited and
                    self.can_jump(row, col, new_row, new_col)):
                possible_moves.add((new_row, new_col))
                visited.add((new_row, new_col))
                next_jumps = self.get_possible_jumps(new_row, new_col, visited)
                possible_moves.update(next_jumps)

        return possible_moves

    def draw(self, possible_moves):
        self.game.screen.fill(white)
        desk_rect = self.game.desk_img.get_rect()
        desk_rect.left = board_offset - 27
        desk_rect.top = board_offset_y - 27
        self.game.screen.blit(self.game.desk_img, desk_rect)

        for row in range(board_size):
            for col in range(board_size):
                pygame.draw.rect(self.game.screen, (197, 201, 209),
                                 (col * cell_size + board_offset,
                                  row * cell_size + board_offset_y,
                                  cell_size, cell_size), 2)
                if (row, col) in possible_moves:
                    pygame.draw.rect(self.game.screen, (6, 21, 51),
                                     (col * cell_size + board_offset,
                                      row * cell_size + board_offset_y,
                                      cell_size, cell_size), 2)

        for row in range(board_size):
            for col in range(board_size):
                if self.board[row][col]:
                    self.board[row][col].draw()

    def get_possible_moves(self, row, col):
        moves = set()

        for d_row, d_col in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            new_row = row + d_row
            new_col = col + d_col
            if (0 <= new_row < board_size and
                    0 <= new_col < board_size and
                    self.board[new_row][new_col] is None):
                moves.add((new_row, new_col))

        jumps = self.get_possible_jumps(row, col)
        moves.update(jumps)

        return moves

    def make_computer_move(self):
        if self.game.animating:
            return False

        def minimax(board, depth, alpha, beta, maximizing_player):
            if depth == 0:
                # Оцениваем состояние доски используя матрицу весов
                score = 0
                for row in range(board_size):
                    for col in range(board_size):
                        if board[row][col] and board[row][col].player == -1:
                            score += self.game.weight_pole[row][col]
                        elif board[row][col] and board[row][col].player == 1:
                            score -= self.game.weight_pole[row][col]
                return score, None, None, None, None

            if maximizing_player:
                max_eval = float('-inf')
                best_move = None
                best_start = None

                # Получаем все возможные ходы для черных фигур
                for row in range(board_size):
                    for col in range(board_size):
                        if board[row][col] and board[row][col].player == -1:
                            possible_moves = self.get_possible_moves(row, col)

                            for new_row, new_col in possible_moves:
                                # Делаем ход
                                temp = board[new_row][new_col]
                                board[new_row][new_col] = board[row][col]
                                board[row][col] = None

                                eval, _, _, _, _ = minimax(board, depth - 1, alpha, beta, False)

                                # Отменяем ход
                                board[row][col] = board[new_row][new_col]
                                board[new_row][new_col] = temp

                                if eval > max_eval:
                                    max_eval = eval
                                    best_move = (new_row, new_col)
                                    best_start = (row, col)

                                alpha = max(alpha, eval)
                                if beta <= alpha:
                                    break

                return max_eval, best_start[0], best_start[1], best_move[0], best_move[1]

            else:
                min_eval = float('inf')
                best_move = None
                best_start = None

                # Получаем все возможные ходы для белых фигур
                for row in range(board_size):
                    for col in range(board_size):
                        if board[row][col] and board[row][col].player == 1:
                            possible_moves = self.get_possible_moves(row, col)

                            for new_row, new_col in possible_moves:
                                # Делаем ход
                                temp = board[new_row][new_col]
                                board[new_row][new_col] = board[row][col]
                                board[row][col] = None

                                eval, _, _, _, _ = minimax(board, depth - 1, alpha, beta, True)

                                # Отменяем ход
                                board[row][col] = board[new_row][new_col]
                                board[new_row][new_col] = temp

                                if eval < min_eval:
                                    min_eval = eval
                                    best_move = (new_row, new_col)
                                    best_start = (row, col)

                                beta = min(beta, eval)
                                if beta <= alpha:
                                    break

                return min_eval, best_start[0], best_start[1], best_move[0], best_move[1]

        # Вызываем minimax с глубиной 3 (можно настроить для разных уровней сложности)
        _, start_row, start_col, end_row, end_col = minimax(self.board, 4, float('-inf'), float('inf'), True)

        if start_row is not None and end_row is not None:
            checker = self.board[start_row][start_col]
            path = self.get_path(start_row, start_col, end_row, end_col)

            if path:
                checker.start_animation(path)
                self.game.animating = True
                self.board[start_row][start_col] = None
                self.board[end_row][end_col] = checker
                checker.move(end_row, end_col)
                self.last_move = ((start_row, start_col), (end_row, end_col))
                return True

        return False


class Game:

    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((window_size_w, window_size_h))
        pygame.display.set_caption("Халма")
        self.clock = pygame.time.Clock()

        self.desk_img = pygame.image.load("desk.jpg")
        self.white_checker_img = pygame.image.load("white.png")
        self.black_checker_img = pygame.image.load("black.png")

        self.font = pygame.font.Font(None, 36)

        self.board = Board(self)
        self.selected_checker = None
        self.possible_moves = set()
        self.current_player = 1
        self.error_message = ""
        self.error_timer = 0
        self.is_computer_player = True
        self.animating = False
        self.animation_progress = 0
        self.show_exit_confirmation = False
        self.show_winner_popup = False
        self.winner = 0
        self.login_screen = LoginScreen(self.screen)
        self.logged_in = False

        self.weight_pole = [
            [7, 6, 5, 4, 3, 2, 1, 0],
            [8, 7, 6, 5, 4, 3, 2, 1],
            [9, 8, 7, 6, 5, 4, 3, 2],
            [10, 9, 8, 7, 6, 5, 4, 3],
            [11, 10, 9, 8, 7, 6, 5, 4],
            [12, 11, 10, 9, 8, 7, 6, 5],
            [13, 12, 11, 10, 9, 8, 7, 6],
            [14, 13, 12, 11, 10, 9, 8, 7]
        ]

        self.RULES_TEXT = """
        Правила игры Халма:

        1. Игроки ходят по очереди.
        2. 
        3.
        4.
        5.
        """

        self.moves_history = []
        self.moves_font = pygame.font.SysFont('Arial', 16)
        self.col_to_letter = {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F', 6: 'G', 7: 'H'}
        self.row_to_number = {0: '8', 1: '7', 2: '6', 3: '5', 4: '4', 5: '3', 6: '2', 7: '1'}

    def add_move_to_history(self, start_pos, end_pos, player):
        # Преобразуем координаты в шахматную нотацию
        start_notation = f"{self.col_to_letter[start_pos[1]]}{self.row_to_number[start_pos[0]]}"
        end_notation = f"{self.col_to_letter[end_pos[1]]}{self.row_to_number[end_pos[0]]}"
        move_text = f"{start_notation} → {end_notation}"
        self.moves_history.append((move_text, player))

    def draw_moves_history(self):
        # Заголовки колонок
        white_header = self.font.render("Ходы белых", True, black)
        black_header = self.font.render("Ходы черных", True, black)
        self.screen.blit(white_header, (20, 20))
        self.screen.blit(black_header, (200, 20))

        # Отрисовка истории ходов
        white_y = 60
        black_y = 60
        for move_text, player in self.moves_history:
            text = self.moves_font.render(move_text, True, black)
            if player == 1:  # белые
                self.screen.blit(text, (20, white_y))
                white_y += 25
            else:  # черные
                self.screen.blit(text, (200, black_y))
                black_y += 25

    def show_winner_dialog(self):
        dialog_width = 300
        dialog_height = 150
        dialog_x = (window_size_w - dialog_width) // 2
        dialog_y = (window_size_h - dialog_height) // 2

        dialog_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, dialog_height)
        pygame.draw.rect(self.screen, white, dialog_rect)
        pygame.draw.rect(self.screen, black, dialog_rect, 2)

        winner_text = "Победил игрок: " + ("белые" if self.winner == 1 else "черные")
        text = self.font.render(winner_text, True, black)
        text_rect = text.get_rect(center=(window_size_w // 2, dialog_y + 45))
        self.screen.blit(text, text_rect)

        ok_button = pygame.Rect(dialog_x + 110, dialog_y + 100, 80, 30)
        pygame.draw.rect(self.screen, gray, ok_button)
        ok_text = self.font.render("OK", True, black)
        ok_rect = ok_text.get_rect(center=ok_button.center)
        self.screen.blit(ok_text, ok_rect)

        return ok_button

    def show_rules(self):
        rules_running = True
        while rules_running:
            self.screen.fill(white)
            y = 50

            for line in self.RULES_TEXT.split('\n'):
                text = self.font.render(line, True, black)
                text_rect = text.get_rect(center=(window_size_w // 2, y))
                self.screen.blit(text, text_rect)
                y += 40

            back_button = pygame.Rect(window_size_w // 2 - 50, window_size_h - 100, 100, 40)
            pygame.draw.rect(self.screen, gray, back_button)
            back_text = self.font.render("Назад", True, black)
            back_text_rect = back_text.get_rect(center=back_button.center)
            self.screen.blit(back_text, back_text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if back_button.collidepoint(event.pos):
                        rules_running = False

    def show_menu(self):
        menu_running = True
        while menu_running:
            self.screen.fill(white)

            start_button = pygame.Rect(window_size_w // 2 - 100, window_size_h // 2 - 50, 200, 40)
            rules_button = pygame.Rect(window_size_w // 2 - 100, window_size_h // 2 + 10, 200, 40)

            pygame.draw.rect(self.screen, gray, start_button)
            pygame.draw.rect(self.screen, gray, rules_button)

            start_text = self.font.render("Начать игру", True, black)
            rules_text = self.font.render("Правила игры", True, black)

            start_text_rect = start_text.get_rect(center=start_button.center)
            rules_text_rect = rules_text.get_rect(center=rules_button.center)

            self.screen.blit(start_text, start_text_rect)
            self.screen.blit(rules_text, rules_text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if start_button.collidepoint(event.pos):
                        menu_running = False
                        while not self.logged_in:
                            self.screen.fill(white)
                            for event in pygame.event.get():
                                if event.type == pygame.QUIT:
                                    pygame.quit()
                                    sys.exit()
                                self.login_screen.handle_event(event)
                                if event.type == pygame.MOUSEBUTTONDOWN and self.login_screen.login_btn.collidepoint(
                                        event.pos):
                                    if self.login_screen.login():
                                        self.logged_in = True

                            self.login_screen.draw()
                            pygame.display.flip()

                        return self.show_opponent_selection()
                    if rules_button.collidepoint(event.pos):
                        self.show_rules()

    def show_opponent_selection(self):
        selection_running = True
        while selection_running:
            self.screen.fill(white)

            computer_button = pygame.Rect(window_size_w // 2 - 150, window_size_h // 2 - 50, 350, 40)
            player_button = pygame.Rect(window_size_w // 2 - 150, window_size_h // 2 + 10, 350, 40)

            pygame.draw.rect(self.screen, gray, computer_button)
            pygame.draw.rect(self.screen, gray, player_button)

            computer_text = self.font.render("Играть против компьютера", True, black)
            player_text = self.font.render("Играть против игрока", True, black)

            computer_text_rect = computer_text.get_rect(center=computer_button.center)
            player_text_rect = player_text.get_rect(center=player_button.center)

            self.screen.blit(computer_text, computer_text_rect)
            self.screen.blit(player_text, player_text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if computer_button.collidepoint(event.pos):
                        self.is_computer_player = True
                        return True
                    if player_button.collidepoint(event.pos):
                        self.is_computer_player = False
                        return True

    def show_exit_dialog(self):
        dialog_width = 300
        dialog_height = 150
        dialog_x = (window_size_w - dialog_width) // 2
        dialog_y = (window_size_h - dialog_height) // 2

        dialog_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, dialog_height)
        pygame.draw.rect(self.screen, white, dialog_rect)
        pygame.draw.rect(self.screen, black, dialog_rect, 2)

        text = self.font.render("Вы хотите закрыть игру", True, black)
        text2 = self.font.render("без сохранения?", True, black)
        text_rect = text.get_rect(center=(window_size_w // 2, dialog_y + 30))
        text2_rect = text2.get_rect(center=(window_size_w // 2, dialog_y + 60))
        self.screen.blit(text, text_rect)
        self.screen.blit(text2, text2_rect)

        yes_button = pygame.Rect(dialog_x + 50, dialog_y + 100, 80, 30)
        no_button = pygame.Rect(dialog_x + 170, dialog_y + 100, 80, 30)

        pygame.draw.rect(self.screen, gray, yes_button)
        pygame.draw.rect(self.screen, gray, no_button)

        yes_text = self.font.render("Да", True, black)
        no_text = self.font.render("Нет", True, black)

        yes_rect = yes_text.get_rect(center=yes_button.center)
        no_rect = no_text.get_rect(center=no_button.center)

        self.screen.blit(yes_text, yes_rect)
        self.screen.blit(no_text, no_rect)

        return yes_button, no_button

    def main_game(self):
        exit_button = pygame.Rect(20, window_size_h - 40, 40, 30)

        while True:
            self.clock.tick(fps)

            if self.current_player == -1 and self.is_computer_player and not self.animating:
                if self.board.make_computer_move():
                    # Добавляем ход компьютера в историю
                    last_move = self.board.last_move
                    if last_move:
                        self.add_move_to_history(last_move[0], last_move[1], -1)
                    self.current_player = 1
                    self.error_message = ""

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN and not self.animating:
                    mouse_pos = event.pos

                    if exit_button.collidepoint(mouse_pos) and not self.show_exit_confirmation:
                        self.show_exit_confirmation = True
                    elif self.show_exit_confirmation:
                        yes_button, no_button = self.show_exit_dialog()
                        if yes_button.collidepoint(mouse_pos):
                            return
                        elif no_button.collidepoint(mouse_pos):
                            self.show_exit_confirmation = False
                    else:
                        if self.current_player == 1 or not self.is_computer_player:
                            col = (mouse_pos[0] - board_offset) // cell_size
                            row = (mouse_pos[1] - board_offset_y) // cell_size

                            if 0 <= row < board_size and 0 <= col < board_size:
                                self.handle_click(row, col)

            self.screen.fill(white)
            self.board.draw(self.possible_moves)
            self.draw_moves_history()
            self.draw_interface(exit_button)
            if self.show_exit_confirmation:
                self.show_exit_dialog()
            pygame.display.flip()

    def handle_click(self, row, col):
        if self.selected_checker:
            can_move = False

            if (self.board.board[row][col] is None and
                    ((abs(self.selected_checker.row - row) == 1 and self.selected_checker.col == col) or
                     (abs(self.selected_checker.col - col) == 1 and self.selected_checker.row == row))):
                can_move = True
            elif (row, col) in self.possible_moves:
                can_move = True

            if can_move:
                # Сохраняем начальную позицию
                start_pos = (self.selected_checker.row, self.selected_checker.col)

                path = self.board.get_path(self.selected_checker.row, self.selected_checker.col, row, col)
                self.selected_checker.start_animation(path)
                self.animating = True

                self.board.board[self.selected_checker.row][self.selected_checker.col] = None
                self.board.board[row][col] = self.selected_checker

                # Добавляем ход в историю для обоих игроков
                self.add_move_to_history(start_pos, (row, col), self.current_player)

                self.current_player = -self.current_player
                self.error_message = ""
            else:
                self.error_message = "Такой ход сейчас не доступен!"
                self.error_timer = 300

            self.selected_checker.selected = False
            self.selected_checker = None
            self.possible_moves = set()
        elif self.board.board[row][col] and self.board.board[row][col].player == self.current_player:
            self.selected_checker = self.board.board[row][col]
            self.selected_checker.selected = True
            self.possible_moves = self.board.get_possible_moves(row, col)

    def draw_interface(self, exit_button):
        pygame.draw.rect(self.screen, gray, exit_button)
        exit_text = self.font.render("<=", True, black)
        exit_text_rect = exit_text.get_rect(center=exit_button.center)
        self.screen.blit(exit_text, exit_text_rect)

        player_text = f"Ходят: {'белые' if self.current_player == 1 else 'черные'}"
        text_surface = self.font.render(player_text, True, black)
        text_rect = text_surface.get_rect(center=(window_size_w // 2, window_size_h - 30))
        self.screen.blit(text_surface, text_rect)

        if self.error_message and self.error_timer > 0:
            error_surface = self.font.render(self.error_message, True, (77, 19, 19))
            error_rect = error_surface.get_rect(center=(window_size_w // 2, window_size_h - 60))
            self.screen.blit(error_surface, error_rect)
            self.error_timer -= 1


def main():
    game = Game()
    while True:
        if game.show_menu():
            game.main_game()


if __name__ == "__main__":
    main()
